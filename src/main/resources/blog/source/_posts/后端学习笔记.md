---
title: 后端学习笔记
date: 2017-07-06 09:57:21
tags: Java
---

主要记录日常工作中或学习中的一些心得笔记，可持续更新....<!--more-->

# Spring Boot 阅读心得

* 实例化构造方法时，先去初始化成员变量，且只初始化非static成员变量和有new 关键字的成员变量。初始化完成后再调用构造方法内部的代码。
* String... 这种定义称为变长变量，可支持传入任意多个参数，可接收数组参数。
* Arrays.asList()实现数组转换为List的功能，具体实现为：new ArrayList<>(数组参数)。

# 网络基础知识

* HTTP是无链接无状态的
* HTTP与服务器交互的四种模式：GET、POST、PUT、DELETE
* URL全称为资源描述符
* 幂等，今天还是第一次听说这个词语，本意即：同一个URL多次请求返回同样的结果，get了。
* GET请求收到长度限制，这个限制一般来源于浏览器
* 三次握手操作：
* 第一次 State：SYN_SEND，Client：SYN=1,seq=x ——> Server 
* 第二次 State:SYN_RCVD，Server: SYN=1,ACK=1,seq=y,ACKnum=x+1 ——> Client 
* 第三次 State:ESTABLISHED ，Client: ACK=1，ACKnum=y+1 ——> Server

# 二叉树知识

* 第i层最多有2^(i-1)个节点
* 高度为k的二叉树其节点最多2^k-1
* 满二叉树，深度为k则节点数为2^k-1
* 完全二叉树：除最后一层以外，上面的为满二叉树，最后一层只缺少右边的若干结点
* 完全二叉树大堆：任意一个非终端节点元素>=左儿子节点和右儿子节点
* 完全二叉树小堆：任意一个非终端节点元素<=左儿子节点和右儿子节点

# 单例模式
* 通常情况下，单例模式三个步骤：构造器私有化，声明私有静态变量，提供静态获取实例的方法

* 最基本的饿汉单例模式（两私一公），涉及线程安全问题。
```java
public class Signleton{
	private static Signleton instence = new Signleton();
	private Signleton(){
	};
	public static Signleton getInstence(){
		return instence;
	} 
}
```

* 懒汉和懒汉线程安全单例如下：
```java
public class SignletonLazy {
	private static SignletonLazy instence;
	private SignletonLazy(){
	};
	// 非线程安全
	public static SignletonLazy getInstence(){
		if(instence == null){
			instence = new SignletonLazy();
		}
		return instence;
	}
	// 线程安全，效率低下
	public static synchronized SignletonLazy getInstence(){
		if(instence == null){
			instence = new SignletonLazy();
		}
		return instence;
	}
}
```

* 双重校验锁（double checked locking）单例模式：
```java
public class SignletonDoubleCheck {
	private static SignletonDoubleCheck instence;
	private SignletonDoubleCheck(){
	};
	public static SignletonDoubleCheck getInstence(){
		if(instence == null){
			synchronized (SignletonDoubleCheck.class) {
				if(instence == null){
					instence = new SignletonDoubleCheck();
				}
			}
		}
		return instence;
	}
}
```

* 枚举单例（Enum Singleton）使用方式为：SignletonEnum signleton = SignletonEnum.INSTANCE 模式：
```java
public enum SignletonEnum {
	INSTANCE
}
```
* 单例总结：一般单例都是五种写法。懒汉，恶汉，双重校验锁，枚举和静态内部类。

# String 基础知识
* String a = "hello"与String a = new String("hello")内存中的区别：
* String a = "hello"如果常量池"hello"存在，则直接指向常量池的"hello",如果没有则在常量池中生成"hello"字符串，并让a指向它
* String a = new String("hello")总是生成一个String对象的引用
* String的+操作与StringBuilder.append()并非总是差，如果String的+操作在编译时合并那么优于append()方法
* 对象存储于堆中，栈中只存储引用地址，而对于八种基础数据类型栈中直接存储的值而非引用

# Integer ==与equals
* 当Integer定义的变量值范围：[-128,127]之间时可用==比较为true
* 当Integer值不在此范围内时，也必须使用equals来比较

# Jvm基础知识
* Jvm分为栈和堆两块区域，栈中存储的变量引用，堆上存储的实例化对象。栈是线程独占，所以线程被销毁，栈上的内存自然被回收，栈不在GC范围内
* GC常用的算法：引用计数算法、可达性分析算法
* 对象是否“已死”算法——引用算法：实例化对象引用为0时则会被GC回收，然而会产生循环引用，永远得不到释放。
* 对象是否“已死”算法——可达性分析算法：通过GC Roots对象向下搜索并标记，未被标记的对象则为可被回收的对象。
* GC算法——标记清除算法：被标记为可被回收的对象直接进行清除
* GC算法——复制算法：将不用回收的内存复制到新的内存区域，然后清除掉连续的内存区域
* Jvm堆中分为：新生代（GC复制算法）和老生代（GC标记压缩算法）。新生代分为：Eden空间、To Survivor空间、From Survivor空间
* 新对象实例化时通常在Eden空间
* GC算法——标记压缩算法：对于被标记为可被回收的对象压缩到内存的一端，然后直接清除边界处的内存。